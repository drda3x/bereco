!function () {
    function t(t, a) {
        return{type: "Feature", id: t.id, properties: t.properties, geometry: n(t.geometry, a)}
    }

    function n(t, a) {
        if (!t)return null;
        if ("GeometryCollection" === t.type)return{type: "GeometryCollection", geometries: object.geometries.map(function (t) {
            return n(t, a)
        })};
        if (!Ma.hasOwnProperty(t.type))return null;
        var r = Ma[t.type];
        return d3.geo.stream(t, a(r)), r.result()
    }

    function a() {
    }

    function r(t) {
        if ((n = t.length) < 4)return!1;
        for (var n, a = 0, r = t[n - 1][1] * t[0][0] - t[n - 1][0] * t[0][1]; ++a < n;)r += t[a - 1][1] * t[a][0] - t[a - 1][0] * t[a][1];
        return 0 >= r
    }

    function e(t, n) {
        for (var a = n[0], r = n[1], e = !1, o = 0, i = t.length, h = i - 1; i > o; h = o++) {
            var u = t[o], M = u[0], s = u[1], c = t[h], f = c[0], v = c[1];
            s > r ^ v > r && (f - M) * (r - s) / (v - s) + M > a && (e = !e)
        }
        return e
    }

    function o(t) {
        return t ? t / Math.sin(t) : 1
    }

    function i(t) {
        return t > 0 ? 1 : 0 > t ? -1 : 0
    }

    function h(t) {
        return t > 1 ? va : -1 > t ? -va : Math.asin(t)
    }

    function u(t) {
        return t > 1 ? 0 : -1 > t ? fa : Math.acos(t)
    }

    function M(t) {
        return t > 0 ? Math.sqrt(t) : 0
    }

    function s(t) {
        function n(t, n) {
            var a = Math.cos(t), e = Math.cos(n), o = Math.sin(n), i = e * a, h = -((1 - i ? Math.log(.5 * (1 + i)) / (1 - i) : -.5) + r / (1 + i));
            return[h * e * Math.sin(t), h * o]
        }

        var a = Math.tan(.5 * t), r = 2 * Math.log(Math.cos(.5 * t)) / (a * a);
        return n.invert = function (n, a) {
            var e, o = Math.sqrt(n * n + a * a), i = t * -.5, u = 50;
            if (!o)return[0, 0];
            do {
                var M = .5 * i, s = Math.cos(M), c = Math.sin(M), f = Math.tan(M), v = Math.log(1 / s);
                i -= e = (2 / f * v - r * f - o) / (-v / (c * c) + 1 - r / (2 * s * s))
            } while (Math.abs(e) > sa && --u > 0);
            var l = Math.sin(i);
            return[Math.atan2(n * l, o * Math.cos(i)), h(a * l / o)]
        }, n
    }

    function c() {
        var t = va, n = pa(s), a = n(t);
        return a.radius = function (a) {
            return arguments.length ? n(t = a * fa / 180) : t / fa * 180
        }, a
    }

    function f(t, n) {
        var a = Math.cos(n), r = o(u(a * Math.cos(t /= 2)));
        return[2 * a * Math.sin(t) * r, Math.sin(n) * r]
    }

    function v(t) {
        function n(t, n) {
            var h = Math.cos(n), u = Math.cos(t /= 2);
            return[(1 + h) * Math.sin(t), (e * n > -Math.atan2(u, o) - .001 ? 0 : 10 * -e) + i + Math.sin(n) * r - (1 + h) * a * u]
        }

        var a = Math.sin(t), r = Math.cos(t), e = t > 0 ? 1 : -1, o = Math.tan(e * t), i = (1 + a - r) / 2;
        return n.invert = function (t, n) {
            var h = 0, u = 0, M = 50;
            do {
                var s = Math.cos(h), c = Math.sin(h), f = Math.cos(u), v = Math.sin(u), l = 1 + f, g = l * c - t, d = i + v * r - l * a * s - n, b = .5 * l * s, p = -c * v, w = .5 * a * l * c, q = r * f + a * s * v, m = p * w - q * b, y = .5 * (d * p - g * q) / m, S = (g * w - d * b) / m;
                h -= y, u -= S
            } while ((Math.abs(y) > sa || Math.abs(S) > sa) && --M > 0);
            return e * u > -Math.atan2(Math.cos(h), o) - .001 ? [2 * h, u] : null
        }, n
    }

    function l() {
        var t = fa / 9, n = t > 0 ? 1 : -1, a = Math.tan(n * t), r = pa(v), e = r(t), o = e.stream;
        return e.parallel = function (e) {
            return arguments.length ? (a = Math.tan((n = (t = e * fa / 180) > 0 ? 1 : -1) * t), r(t)) : t / fa * 180
        }, e.stream = function (r) {
            var i = e.rotate(), h = o(r), u = (e.rotate([0, 0]), o(r));
            return e.rotate(i), h.sphere = function () {
                u.polygonStart(), u.lineStart();
                for (var r = -180 * n; 180 > n * r; r += 90 * n)u.point(r, 90 * n);
                for (; n * (r -= t) >= -180;)u.point(r, n * -Math.atan2(Math.cos(r * ga / 2), a) * da);
                u.lineEnd(), u.polygonEnd()
            }, h
        }, e
    }

    function g(t) {
        return t = Math.exp(2 * t), (t - 1) / (t + 1)
    }

    function d(t) {
        return.5 * (Math.exp(t) - Math.exp(-t))
    }

    function b(t) {
        return.5 * (Math.exp(t) + Math.exp(-t))
    }

    function p(t) {
        return Math.log(t + M(t * t + 1))
    }

    function w(t) {
        return Math.log(t + M(t * t - 1))
    }

    function q(t, n) {
        var a = Math.tan(n / 2), r = M(1 - a * a), e = 1 + r * Math.cos(t /= 2), o = Math.sin(t) * r / e, i = a / e, h = o * o, u = i * i;
        return[4 / 3 * o * (3 + h - 3 * u), 4 / 3 * i * (3 + 3 * h - u)]
    }

    function m(t, n) {
        var a = Math.abs(n);
        return fa / 4 > a ? [t, Math.log(Math.tan(fa / 4 + n / 2))] : [t * Math.cos(a) * (2 * Math.SQRT2 - 1 / Math.sin(a)), i(n) * (2 * Math.SQRT2 * (a - fa / 4) - Math.log(Math.tan(a / 2)))]
    }

    function y(t) {
        function n(t, n) {
            var r = qa(t, n);
            if (Math.abs(t) > va) {
                var e = Math.atan2(r[1], r[0]), o = Math.sqrt(r[0] * r[0] + r[1] * r[1]), i = a * Math.round((e - va) / a) + va, u = Math.atan2(Math.sin(e -= i), 2 - Math.cos(e));
                e = i + h(fa / o * Math.sin(u)) - u, r[0] = o * Math.cos(e), r[1] = o * Math.sin(e)
            }
            return r
        }

        var a = 2 * fa / t;
        return n.invert = function (t, n) {
            var r = Math.sqrt(t * t + n * n);
            if (r > va) {
                var e = Math.atan2(n, t), o = a * Math.round((e - va) / a) + va, i = e > o ? -1 : 1, h = r * Math.cos(o - e), u = 1 / Math.tan(i * Math.acos((h - fa) / Math.sqrt(fa * (fa - 2 * h) + r * r)));
                e = o + 2 * Math.atan((u + i * Math.sqrt(u * u - 3)) / 3), t = r * Math.cos(e), n = r * Math.sin(e)
            }
            return qa.invert(t, n)
        }, n
    }

    function S() {
        var t = 5, n = pa(y), a = n(t), r = a.stream, e = .01, o = -Math.cos(e * ga), i = Math.sin(e * ga);
        return a.lobes = function (a) {
            return arguments.length ? n(t = +a) : t
        }, a.stream = function (n) {
            var u = a.rotate(), M = r(n), s = (a.rotate([0, 0]), r(n));
            return a.rotate(u), M.sphere = function () {
                s.polygonStart(), s.lineStart();
                for (var n = 0, a = 360 / t, r = 2 * fa / t, u = 90 - 180 / t, M = va; t > n; ++n, u -= a, M -= r)s.point(Math.atan2(i * Math.cos(M), o) * da, h(i * Math.sin(M)) * da), -90 > u ? (s.point(-90, -180 - u - e), s.point(-90, -180 - u + e)) : (s.point(90, u + e), s.point(90, u - e));
                s.lineEnd(), s.polygonEnd()
            }, M
        }, a
    }

    function Q(t) {
        return function (n) {
            var a, r = t * Math.sin(n), e = 30;
            do n -= a = (n + Math.sin(n) - r) / (1 + Math.cos(n)); while (Math.abs(a) > sa && --e > 0);
            return n / 2
        }
    }

    function R(t, n, a) {
        function r(a, r) {
            return[t * a * Math.cos(r = e(r)), n * Math.sin(r)]
        }

        var e = Q(a);
        return r.invert = function (r, e) {
            var o = h(e / n);
            return[r / (t * Math.cos(o)), h((2 * o + Math.sin(2 * o)) / a)]
        }, r
    }

    function T(t, n) {
        var a = 2.00276, r = ma(n);
        return[a * t / (1 / Math.cos(n) + 1.11072 / Math.cos(r)), (n + Math.SQRT2 * Math.sin(r)) / a]
    }

    function x(t) {
        var n = 0, a = pa(t), r = a(n);
        return r.parallel = function (t) {
            return arguments.length ? a(n = t * fa / 180) : n / fa * 180
        }, r
    }

    function E(t, n) {
        return[t * Math.cos(n), n]
    }

    function P(t) {
        function n(n, r) {
            var e = a + t - r, o = e ?

            geo.interrupt = function (t) {
                function n(n, a) {
                    for (var r = 0 > a ? -1 : 1, e = h[+(0 > a)], o = 0, i = e.length - 1; i > o && n > e[o][2][0]; ++o);
                    var u = t(n - e[o][1][0], a);
                    return u[0] += t(e[o][1][0], r * a > r * e[o][0][1] ? e[o][0][1] : a)[0], u
                }

                function a() {
                    i = h.map(function (n) {
                        return n.map(function (n) {
                            var a, r = t(n[0][0], n[0][1])[0], e = t(n[2][0], n[2][1])[0], o = t(n[1][0], n[0][1])[1], i = t(n[1][0], n[1][1])[1];
                            return o > i && (a = o, o = i, i = a), [
                                [r, o],
                                [e, i]
                            ]
                        })
                    })
                }

                function r() {
                    for (var t = 1e-6, n = [], a = 0, r = h[0].length; r > a; ++a) {
                        var o = h[0][a], i = 180 * o[0][0] / fa, u = 180 * o[0][1] / fa, M = 180 * o[1][1] / fa, s = 180 * o[2][0] / fa, c = 180 * o[2][1] / fa;
                        n.push(e([
                            [i + t, u + t],
                            [i + t, M - t],
                            [s - t, M - t],
                            [s - t, c + t]
                        ], 30))
                    }
                    for (var a = h[1].length - 1; a >= 0; --a) {
                        var o = h[1][a], i = 180 * o[0][0] / fa, u = 180 * o[0][1] / fa, M = 180 * o[1][1] / fa, s = 180 * o[2][0] / fa, c = 180 * o[2][1] / fa;
                        n.push(e([
                            [s - t, c - t],
                            [s - t, M + t],
                            [i + t, M + t],
                            [i + t, u - t]
                        ], 30))
                    }
                    return{type: "Polygon", coordinates: [d3.merge(n)]}
                }

                function e(t, n) {
                    for (var a, r, e, o = -1, i = t.length, h = t[0], u = []; ++o < i;) {
                        a = t[o], r = (a[0] - h[0]) / n, e = (a[1] - h[1]) / n;
                        for (var M = 0; n > M; ++M)u.push([h[0] + M * r, h[1] + M * e]);
                        h = a
                    }
                    return u.push(a), u
                }

                function o(t, n) {
                    return Math.abs(t[0] - n[0]) < sa && Math.abs(t[1] - n[1]) < sa
                }

                var i, h = [
                    [
                        [
                            [-fa, 0],
                            [0, va],
                            [fa, 0]
                        ]
                    ],
                    [
                        [
                            [-fa, 0],
                            [0, -va],
                            [fa, 0]
                        ]
                    ]
                ];
                t.invert && (n.invert = function (a, r) {
                    for (var e = i[+(0 > r)], u = h[+(0 > r)], M = 0, s = e.length; s > M; ++M) {
                        var c = e[M];
                        if (c[0][0] <= a && a < c[1][0] && c[0][1] <= r && r < c[1][1]) {
                            var f = t.invert(a - t(u[M][1][0], 0)[0], r);
                            return f[0] += u[M][1][0], o(n(f[0], f[1]), [a, r]) ? f : null
                        }
                    }
                });
                var u = d3.geo.projection(n), M = u.stream;
                return u.stream = function (t) {
                    var n = u.rotate(), a = M(t), e = (u.rotate([0, 0]), M(t));
                    return u.rotate(n), a.sphere = function () {
                        d3.geo.stream(r(), e)
                    }, a
                }, u.lobes = function (t) {
                    return arguments.length ? (h = t.map(function (t) {
                        return t.map(function (t) {
                            return[
                                [t[0][0] * fa / 180, t[0][1] * fa / 180],
                                [t[1][0] * fa / 180, t[1][1] * fa / 180],
                                [t[2][0] * fa / 180, t[2][1] * fa / 180]
                            ]
                        })
                    }), a(), u) : h.map(function (t) {
                        return t.map(function (t) {
                            return[
                                [180 * t[0][0] / fa, 180 * t[0][1] / fa],
                                [180 * t[1][0] / fa, 180 * t[1][1] / fa],
                                [180 * t[2][0] / fa, 180 * t[2][1] / fa]
                            ]
                        })
                    })
                }, u
            }, (d3.geo.airy = c).raw = s, f.invert = function (t, n) {
                if (!(t * t + 4 * n * n > fa * fa + sa)) {
                    var a = t, r = n, e = 25;
                    do {
                        var o, i = Math.sin(a), h = Math.sin(a / 2), M = Math.cos(a / 2), s = Math.sin(r), c = Math.cos(r), f = Math.sin(2 * r), v = s * s, l = c * c, g = h * h, d = 1 - l * M * M, b = d ? u(c * M) * Math.sqrt(o = 1 / d) : o = 0, p = 2 * b * c * h - t, w = b * s - n, q = o * (l * g + b * c * M * v), m = o * (.5 * i * f - 2 * b * s * h), y = .25 * o * (f * h - b * s * l * i), S = o * (v * M + b * g * c), Q = m * y - S * q;
                        if (!Q)break;
                        var R = (w * m - p * S) / Q, T = (p * y - w * q) / Q;
                        a -= R, r -= T
                    } while ((Math.abs(R) > sa || Math.abs(T) > sa) && --e > 0);
                    return[a, r]
                }
            }, (d3.geo.aitoff = function () {
                return ba(f)
            }).raw = f, (d3.geo.armadillo = l).raw = v, q.invert = function (t, n) {
                if (t *= 3 / 8, n *= 3 / 8, !t && Math.abs(n) > 1)return null;
                var a = t * t, r = n * n, e = 1 + a + r, o = Math.sqrt(.5 * (e - Math.sqrt(e * e - 4 * n * n))), u = h(o) / 3, M = o ? w(Math.abs(n / o)) / 3 : p(Math.abs(t)) / 3, s = Math.cos(u), c = b(M), f = c * c - s * s;
                return[2 * i(t) * Math.atan2(d(M) * s, .25 - f), 2 * i(n) * Math.atan2(c * Math.sin(u), .25 + f)]
            }, (d3.geo.august = function () {
                return ba(q)
            }).raw = q;
            var wa = Math.log(1 + Math.SQRT2);
            m.invert = function (t, n) {
                if ((r = Math.abs(n)) < wa)return[t, 2 * Math.atan(Math.exp(n)) - va];
                var a, r, e = Math.sqrt(8), o = fa / 4, h = 25;
                do {
                    var u = Math.cos(o / 2), M = Math.tan(o / 2);
                    o -= a = (e * (o - fa / 4) - Math.log(M) - r) / (e - .5 * u * u / M)
                } while (Math.abs(a) > ca && --h > 0);
                return[t / (Math.cos(o) * (e - 1 / Math.sin(o))), i(n) * o]
            }, (d3.geo.baker = function () {
                return ba(m)
            }).raw = m;
            var qa = d3.geo.azimuthalEquidistant.raw;
            (d3.geo.berghaus = S).raw = y;
            var ma = Q(fa), ya = R(Math.SQRT2 / va, Math.SQRT2, fa);
            (d3.geo.mollweide = function () {
                return ba(ya)
            }).raw = ya, T.invert = function (t, n) {
                var a, r, e = 2.00276, o = e * n, i = 0 > n ? -fa / 4 : fa / 4, h = 25;
                do r = o - Math.SQRT2 * Math.sin(i), i -= a = (Math.sin(2 * i) + 2 * i - fa * Math.sin(r)) / (2 * Math.cos(2 * i) + 2 + fa * Math.cos(r) * Math.SQRT2 * Math.cos(i)); while (Math.abs(a) > sa && --h > 0);
                return r = o - Math.SQRT2 * Math.sin(i), [t * (1 / Math.cos(r) + 1.11072 / Math.cos(i)) / e, r]
            }, (d3.geo.boggs = function () {
                return ba(T)
            }).raw = T, E.invert = function (t, n) {
                return[t / Math.cos(n), n]
            }, (d3.geo.sinusoidal = function () {
                return ba(E)
            }).raw = E, (d3.geo.bonne = function () {
                return x(P).parallel(45)
            }).raw = P;
            var Sa = R(1, 4 / fa, fa);
            (d3.geo.bromley = function () {
                return ba(Sa)
            }).raw = Sa, (d3.geo.chamberlin = _).raw = k, G.invert = function (t, n) {
                var a = (a = n / la - 1) * a;
                return[a > 0 ? t * Math.sqrt(fa / a) / 2 : 0, h(1 - a)]
            }, (d3.geo.collignon = function () {
                return ba(G)
            }).raw = G, (d3.geo.craig = function () {
                return x(j)
            }).raw = j, C.invert = function (t, n) {
                var a = Math.sqrt(3), r = 3 * h(n / (a * la));
                return[la * t / (a * (2 * Math.cos(2 * r / 3) - 1)), r]
            }, (d3.geo.craster = function () {
                return ba(C)
            }).raw = C, (d3.geo.cylindricalEqualArea = function () {
                return x(D)
            }).raw = D, (d3.geo.cylindricalStereographic = function () {
                return x(L)
            }).raw = L, O.invert = function (t, n) {
                var a = Math.sqrt(8 / (3 * fa)), r = n / a;
                return[t / (a * (1 - Math.abs(r) / fa)), r]
            }, (d3.geo.eckert1 = function () {
                return ba(O)
            }).raw = O, H.invert = function (t, n) {
                var a = 2 - Math.abs(n) / Math.sqrt(2 * fa / 3);
                return[t * Math.sqrt(6 * fa) / (2 * a), i(n) * h((4 - a * a) / 3)]
            }, (d3.geo.eckert2 = function () {
                return ba(H)
            }).raw = H, I.invert = function (t, n) {
                var a = Math.sqrt(fa * (4 + fa)) / 2;
                return[t * a / (1 + M(1 - n * n * (4 + fa) / (4 * fa))), n * a / 2]
            }, (d3.geo.eckert3 = function () {
                return ba(I)
            }).raw = I, J.invert = function (t, n) {
                var a = .5 * n * Math.sqrt((4 + fa) / fa), r = h(a), e = Math.cos(r);
                return[t / (2 / Math.sqrt(fa * (4 + fa)) * (1 + e)), h((r + a * (e + 2)) / (2 + va))]
            }, (d3.geo.eckert4 = function () {
                return ba(J)
            }).raw = J, K.invert = function (t, n) {
                var a = Math.sqrt(2 + fa), r = n * a / 2;
                return[a * t / (1 + Math.cos(r)), r]
            }, (d3.geo.eckert5 = function () {
                return ba(K)
            }).raw = K, N.invert = function (t, n) {
                var a = 1 + va, r = Math.sqrt(a / 2);
                return[2 * t * r / (1 + Math.cos(n *= r)), h((n + Math.sin(n)) / a)]
            }, (d3.geo.eckert6 = function () {
                return ba(N)
            }).raw = N, U.invert = function (t, n) {
                var a = d3.geo.august.raw.invert(t / 1.2, 1.065 * n);
                if (!a)return null;
                var r = a[0], e = a[1], o = 20;
                t /= Qa, n /= Qa;
                do {
                    var i = r / 2, h = e / 2, u = Math.sin(i), M = Math.cos(i), s = Math.sin(h), c = Math.cos(h), f = Math.cos(e), v = Math.sqrt(f), l = s / (c + Math.SQRT2 * M * v), g = l * l, d = Math.sqrt(2 / (1 + g)), b = Math.SQRT2 * c + (M + u) * v, p = Math.SQRT2 * c + (M - u) * v, w = b / p, q = Math.sqrt(w), m = q - 1 / q, y = q + 1 / q, S = d * m - 2 * Math.log(q) - t, Q = d * l * y - 2 * Math.atan(l) - n, R = s && Math.SQRT1_2 * v * u * g / s, T = (Math.SQRT2 * M * c + v) / (2 * (c + Math.SQRT2 * M * v) * (c + Math.SQRT2 * M * v) * v), x = -.5 * l * d * d * d, E = x * R, P = x * T, k = (k = 2 * c + Math.SQRT2 * v * (M - u)) * k * q, _ = (Math.SQRT2 * M * c * v + f) / k, z = -(Math.SQRT2 * u * s) / (v * k), B = m * E - 2 * _ / q + d * (_ + _ / w), F = m * P - 2 * z / q + d * (z + z / w), A = l * y * E - 2 * R / (1 + g) + d * y * R + d * l * (_ - _ / w), G = l * y * P - 2 * T / (1 + g) + d * y * T + d * l * (z - z / w), j = F * A - G * B;
                    if (!j)break;
                    var C = (Q * F - S * G) / j, D = (S * A - Q * B) / j;
                    r -= C, e = Math.max(-va, Math.min(va, e - D))
                } while ((Math.abs(C) > sa || Math.abs(D) > sa) && --o > 0);
                return Math.abs(Math.abs(e) - va) < sa ? [0, e] : o && [r, e]
            };
            var Qa = 3 + 2 * Math.SQRT2;
            (d3.geo.eisenlohr = function () {
                return ba(U)
            }).raw = U, V.invert = function (t, n) {
                var a = n / (1 + Ra);
                return[t ? t / (Ra * M(1 - a * a)) : 0, 2 * Math.atan(a)]
            };
            var Ra = Math.cos(35 * ga);
            (d3.geo.fahey = function () {
                return ba(V)
            }).raw = V, W.invert = function (t, n) {
                var a = Math.atan(n / la), r = Math.cos(a), e = 2 * a;
                return[t * la * .5 / (Math.cos(e) * r * r), e]
            }, (d3.geo.foucaut = function () {
                return ba(W)
            }).raw = W, d3.geo.gilbert = function (t) {
                function n(n) {
                    return t([.5 * n[0], h(Math.tan(.5 * n[1] * ga)) * da])
                }

                var a = d3.geo.equirectangular().scale(da).translate([0, 0]);
                return t.invert && (n.invert = function (n) {
                    return n = t.invert(n), n[0] *= 2, n[1] = 2 * Math.atan(Math.sin(n[1] * ga)) * da, n
                }), n.stream = function (n) {
                    n = t.stream(n);
                    var r = a.stream({point: function (t, a) {
                        n.point(.5 * t, h(Math.tan(.5 * -a * ga)) * da)
                    }, lineStart: function () {
                        n.lineStart()
                    }, lineEnd: function () {
                        n.lineEnd()
                    }, polygonStart: function () {
                        n.polygonStart()
                    }, polygonEnd: function () {
                        n.polygonEnd()
                    }});
                    return r.sphere = function () {
                        n.sphere()
                    }, r.valid = !1, r
                }, n
            };
            var Ta = X(2.8284, -1.6988, .75432, -.18071, 1.76003, -.38914, .042555);
            (d3.geo.ginzburg4 = function () {
                return ba(Ta)
            }).raw = Ta;
            var xa = X(2.583819, -.835827, .170354, -.038094, 1.543313, -.411435, .082742);
            (d3.geo.ginzburg5 = function () {
                return ba(xa)
            }).raw = xa;
            var Ea = X(5 / 6 * fa, -.62636, -.0344, 0, 1.3493, -.05524, 0, .045);
            (d3.geo.ginzburg6 = function () {
                return ba(Ea)
            }).raw = Ea, Y.invert = function (t, n) {
                var a, r = t, e = n, o = 50;
                do {
                    var i = e * e;
                    e -= a = (e * (1 + i / 12) - n) / (1 + i / 4)
                } while (Math.abs(a) > sa && --o > 0);
                o = 50, t /= 1 - .162388 * i;
                do {
                    var h = (h = r * r) * h;
                    r -= a = (r * (.87 - 952426e-9 * h) - t) / (.87 - .00476213 * h)
                } while (Math.abs(a) > sa && --o > 0);
                return[r, e]
            }, (d3.geo.ginzburg8 = function () {
                return ba(Y)
            }).raw = Y;
            var Pa = X(2.6516, -.76534, .19123, -.047094, 1.36289, -.13965, .031762);
            (d3.geo.ginzburg9 = function () {
                return ba(Pa)
            }).raw = Pa, $.invert = function (t, n) {
                var a = i(t), r = i(n), e = -a * t, o = -r * n, u = 1 > o / e, M = nn(u ? o : e, u ? e : o), s = M[0], c = M[1];
                u && (s = -va - s);
                var f = Math.cos(c), t = Math.cos(s) * f, n = Math.sin(s) * f, v = Math.sin(c);
                return[a * (Math.atan2(n, -v) + fa), r * h(t)]
            }, d3.geo.gringorten = Z($), hn.invert = function (t, n) {
                var a = (Math.SQRT2 - 1) / (Math.SQRT2 + 1), r = Math.sqrt(1 - a * a), e = on(va, r * r), o = -1, i = an(.5 * e - n, -t, r * r), h = Mn(i[0], i[1]), u = Math.atan2(h[1], h[0]) / o;
                return[u, 2 * Math.atan(Math.exp(.5 / o * Math.log(a * h[0] * h[0] + a * h[1] * h[1]))) - va]
            }, d3.geo.guyou = Z(hn), (d3.geo.hammerRetroazimuthal = fn).raw = sn;
            var ka = d3.geo.azimuthalEqualArea.raw;
            gn.invert = function (t, n) {
                var a = 2 * h(n / 2);
                return[t * Math.cos(a / 2) / Math.cos(a), a]
            }, (d3.geo.hammer = ln).raw = vn, dn.invert = function (t, n) {
                var a = Math.abs(a = n * (0 > n ? .5179951515653813 : .5686373742600607)) > 1 - sa ? a > 0 ? va : -va : h(a);
                return[1.1764705882352942 * t / Math.cos(a), Math.abs(a = ((a += a) + Math.sin(a)) * (0 > n ? .4102345310814193 : .3736990601468637)) > 1 - sa ? a > 0 ? va : -va : h(a)]
            }, (d3.geo.hatano = function () {
                return ba(dn)
            }).raw = dn;
            var _a = 41 + 48 / 36 + 37 / 3600;
            (d3.geo.healpix = pn).raw = bn, (d3.geo.hill = qn).raw = wn;
            var za = .7109889596207567, Ba = .0528035274542;
            mn.invert = function (t, n) {
                return n > -za ? ya.invert(t, n - Ba) : E.invert(t, n)
            }, (d3.geo.sinuMollweide = function () {
                return ba(mn).rotate([-20, -55])
            }).raw = mn, yn.invert = function (t, n) {
                return Math.abs(n) > za ? ya.invert(t, n + (n > 0 ? Ba : -Ba)) : E.invert(t, n)
            }, (d3.geo.homolosine = function () {
                return ba(yn)
            }).raw = yn, Sn.invert = function (t, n) {
                return[2 / 3 * fa * t / Math.sqrt(fa * fa / 3 - n * n), n]
            }, (d3.geo.kavrayskiy7 = function () {
                return ba(Sn)
            }).raw = Sn, (d3.geo.lagrange = Rn).raw = Qn, Tn.invert = function (t, n) {
                var a = Math.abs(t), r = Math.abs(n), e = fa / Math.SQRT2, o = sa, i = va;
                e > r ? i *= r / e : o += 6 * u(e / r);
                for (var h = 0; 25 > h; h++) {
                    var s = Math.sin(i), c = M(Math.cos(i)), f = Math.sin(i / 2), v = Math.cos(i / 2), l = Math.sin(o / 6), g = Math.cos(o / 6), d = .5 * o * (1 + c) - a, b = i / (v * g) - r, p = c ? -.25 * o * s / c : 0, w = .5 * (1 + c), q = (1 + .5 * i * f / v) / (v * g), m = i / v * (l / 6) / (g * g), y = p * m - q * w, S = (d * m - b * w) / y, Q = (b * p - d * q) / y;
                    if (i -= S, o -= Q, Math.abs(S) < sa && Math.abs(Q) < sa)break
                }
                return[0 > t ? -o : o, 0 > n ? -i : i]
            }, (d3.geo.larrivee = function () {
                return ba(Tn)
            }).raw = Tn, xn.invert = function (t, n) {
                var a = i(t) * fa, r = n / 2, e
                ...
                n
                )
                {
                    var a, r = n, e = 25;
                    do {
                        var o = r * r, i = o * o;
                        r -= a = (r * (1.007226 + o * (.015085 + i * (-.044475 + .028874 * o - .005916 * i))) - n) / (1.007226 + o * (.045255 + i * (-0.311325 + .259866 * o - .005916 * 11 * i)))
                    } while (Math.abs(a) > sa && --e > 0);
                    return[t / (.8707 + (o = r * r) * (-.131979 + o * (-.013791 + o * o * o * (.003971 - .001529 * o)))), r]
                }
                ,
                (d3.geo.naturalEarth = function () {
                    return ba(Gn)
                }).raw = Gn, jn.invert = function (t, n) {
                    for (var a = n / 2, r = 0, e = 1 / 0; 10 > r && Math.abs(e) > sa; r++) {
                        var o = Math.cos(n / 2);
                        n -= e = (n - Math.tan(n / 2) - a) / (1 - .5 / (o * o))
                    }
                    return[2 * t / (1 + Math.cos(n)), n]
                }, (d3.geo.nellHammer = function () {
                    return ba(jn)
                }).raw = jn;
                var Aa = Z(hn);
                (d3.geo.peirceQuincuncial = function () {
                    return Aa().quincuncial(!0).rotate([-90, -90, 45]).clipAngle(180 - 1e-6)
                }).raw = Aa.raw, Cn.invert = function (t, n) {
                    if (Math.abs(n) < sa)return[t, 0];
                    var a, r = t * t + n * n, e = .5 * n, o = 10;
                    do {
                        var M = Math.tan(e), s = 1 / Math.cos(e), c = r - 2 * n * e + e * e;
                        e -= a = (M * c + 2 * (e - n)) / (2 + c * s * s + 2 * (e - n) * M)
                    } while (Math.abs(a) > sa && --o > 0);
                    return M = Math.tan(e), [(Math.abs(n) < Math.abs(e + 1 / M) ? h(t * M) : i(t) * (u(Math.abs(t * M)) + va)) / Math.sin(e), e]
                }, (d3.geo.polyconic = function () {
                    return ba(Cn)
                }).raw = Cn, (d3.geo.rectangularPolyconic = function () {
                    return x(Dn)
                }).raw = Dn;
                var Ga = [
                    [.9986, -.062],
                    [1, 0],
                    [.9986, .062],
                    [.9954, .124],
                    [.99, .186],
                    [.9822, .248],
                    [.973, .31],
                    [.96, .372],
                    [.9427, .434],
                    [.9216, .4958],
                    [.8962, .5571],
                    [.8679, .6176],
                    [.835, .6769],
                    [.7986, .7346],
                    [.7597, .7903],
                    [.7186, .8435],
                    [.6732, .8936],
                    [.6213, .9394],
                    [.5722, .9761],
                    [.5322, 1]
                ];
                Ga.forEach(function (t) {
                    t[1] *= 1.0144
                }), Ln.invert = function (t, n) {
                    var a = n / va, r = 90 * a, e = Math.min(18, Math.abs(r / 5)), o = Math.max(0, Math.floor(e));
                    do {
                        var i = Ga[o][1], h = Ga[o + 1][1], u = Ga[Math.min(19, o + 2)][1], M = u - i, s = u - 2 * h + i, c = 2 * (Math.abs(a) - h) / M, f = s / M, v = c * (1 - f * c * (1 - 2 * f * c));
                        if (v >= 0 || 1 === o) {
                            r = (n >= 0 ? 5 : -5) * (v + e);
                            var l, g = 50;
                            do e = Math.min(18, Math.abs(r) / 5), o = Math.floor(e), v = e - o, i = Ga[o][1], h = Ga[o + 1][1], u = Ga[Math.min(19, o + 2)][1], r -= (l = (n >= 0 ? va : -va) * (h + v * (u - i) / 2 + v * v * (u - 2 * h + i) / 2) - n) * da; while (Math.abs(l) > ca && --g > 0);
                            break
                        }
                    } while (--o >= 0);
                    var d = Ga[o][0], b = Ga[o + 1][0], p = Ga[Math.min(19, o + 2)][0];
                    return[t / (b + v * (p - d) / 2 + v * v * (p - 2 * b + d) / 2), r * ga]
                }, (d3.geo.robinson = function () {
                    return ba(Ln)
                }).raw = Ln, (d3.geo.satellite = In).raw = Hn, Jn.invert = function (t, n) {
                    var a = n / 1.70711, r = Math.sin(fa / 4 * a);
                    return[t / (.74482 - .34588 * r * r), 2 * Math.atan(a)]
                }, (d3.geo.times = function () {
                    return ba(Jn)
                }).raw = Jn, (d3.geo.twoPointEquidistant = Nn).raw = Kn, (d3.geo.twoPointAzimuthal = Vn).raw = Un, Wn.invert = function (t, n) {
                    if (Math.abs(n) < sa)return[t, 0];
                    if (Math.abs(t) < sa)return[0, va * Math.sin(2 * Math.atan(n / fa))];
                    var a = (t /= fa) * t, r = (n /= fa) * n, e = a + r, o = e * e, h = -Math.abs(n) * (1 + e), M = h - 2 * r + a, s = -2 * h + 1 + 2 * r + o, c = r / s + (2 * M * M * M / (s * s * s) - 9 * h * M / (s * s)) / 27, f = (h - M * M / (3 * s)) / s, v = 2 * Math.sqrt(-f / 3), l = u(3 * c / (f * v)) / 3;
                    return[fa * (e - 1 + Math.sqrt(1 + 2 * (a - r) + o)) / (2 * t), i(n) * fa * (-v * Math.cos(l + fa / 3) - M / (3 * s))]
                }, (d3.geo.vanDerGrinten = function () {
                    return ba(Wn)
                }).raw = Wn, Xn.invert = function (t, n) {
                    if (!t)return[0, va * Math.sin(2 * Math.atan(n / fa))];
                    var a = Math.abs(t / fa), r = (1 - a * a - (n /= fa) * n) / (2 * a), e = r * r, o = Math.sqrt(e + 1);
                    return[i(t) * fa * (o - r), i(n) * va * Math.sin(2 * Math.atan2(Math.sqrt((1 - 2 * r * a) * (r + o) - a), Math.sqrt(o + r + a)))]
                }, (d3.geo.vanDerGrinten2 = function () {
                    return ba(Xn)
                }).raw = Xn, Yn.invert = function (t, n) {
                    if (!n)return[t, 0];
                    var a = n / fa, r = (fa * fa * (1 - a * a) - t * t) / (2 * fa * t);
                    return[t ? fa * (i(t) * Math.sqrt(r * r + 1) - r) : 0, va * Math.sin(2 * Math.atan(a))]
                }, (d3.geo.vanDerGrinten3 = function () {
                    return ba(Yn)
                }).raw = Yn, Zn.invert = function (t, n) {
                    if (!t || !n)return[t, n];
                    n /= fa;
                    var a = i(t) * t / va, r = (a * a - 1 + 4 * n * n) / Math.abs(a), e = r * r, o = 2 * n, h = 50;
                    do {
                        var u = o * o, M = (8 * o - u * (u + 2) - 5) / (2 * u * (o - 1)), s = (3 * o - u * o - 10) / (2 * u * o), c = M * M, f = o * M, v = o + M, l = v * v, g = o + 3 * M, d = l * (u + c * e - 1) + (1 - u) * (u * (g * g + 4 * c) + c * (12 * f + 4 * c)), b = -2 * v * (4 * f * c + (1 - 4 * u + 3 * u * u) * (1 + s) + c * (-6 + 14 * u - e + (-8 + 8 * u - 2 * e) * s) + f * (-8 + 12 * u + (-10 + 10 * u - e) * s)), p = Math.sqrt(d), w = r * (l + c - 1) + 2 * p - a * (4 * l + e), q = r * (2 * M * s + 2 * v * (1 + s)) + b / p - 8 * v * (r * (-1 + c + l) + 2 * p) * (1 + s) / (e + 4 * l);
                        o -= δ = w / q
                    } while (δ > sa && --h > 0);
                    return[i(t) * (Math.sqrt(r * r + 4) + r) * fa / 4, va * o]
                }, (d3.geo.vanDerGrinten4 = function () {
                    return ba(Zn)
                }).raw = Zn;
                var ja = function () {
                    var t = 4 * fa + 3 * Math.sqrt(3), n = 2 * Math.sqrt(2 * fa * Math.sqrt(3) / t);
                    return R(n * Math.sqrt(3) / fa, n, t / 6)
                }();
                (d3.geo.wagner4 = function () {
                    return ba(ja)
                }).raw = ja, $n.invert = function (t, n) {
                    return[t / Math.sqrt(1 - 3 * n * n / (fa * fa)), n]
                }, (d3.geo.wagner6 = function () {
                    return ba($n)
                }).raw = $n, ta.invert = function (t, n) {
                    var a = t / 2.66723, r = n / 1.24104, e = Math.sqrt(a * a + r * r), o = 2 * h(e / 2);
                    return[3 * Math.atan2(t * Math.tan(o), 2.66723 * e), e && h(n * Math.sin(o) / (1.24104 * .90631 * e))]
                }, (d3.geo.wagner7 = function () {
                    return ba(ta)
                }).raw = ta, na.invert = function (t, n) {
                    var a = -.5 * (t * t + n * n), r = Math.sqrt(-a * (2 + a)), e = n * a + t * r, o = t * a - n * r, i = Math.sqrt(o * o + e * e);
                    return[Math.atan2(r * e, i * (1 + a)), i ? -h(r * o / i) : 0]
                }, (d3.geo.wiechel = function () {
                    return ba(na)
                }).raw = na, aa.invert = function (t, n) {
                    var a = t, r = n, e = 25;
                    do {
                        var o, i = Math.cos(r), h = Math.sin(r), M = Math.sin(2 * r), s = h * h, c = i * i, f = Math.sin(a), v = Math.cos(a / 2), l = Math.sin(a / 2), g = l * l, d = 1 - c * v * v, b = d ? u(i * v) * Math.sqrt(o = 1 / d) : o = 0, p = .5 * (2 * b * i * l + a / va) - t, w = .5 * (b * h + r) - n, q = .5 * o * (c * g + b * i * v * s) + .5 / va, m = o * (f * M / 4 - b * h * l), y = .125 * o * (M * l - b * h * c * f), S = .5 * o * (s * v + b * g * i) + .5, Q = m * y - S * q, R = (w * m - p * S) / Q, T = (p * y - w * q) / Q;
                        a -= R, r -= T
                    } while ((Math.abs(R) > sa || Math.abs(T) > sa) && --e > 0);
                    return[a, r]
                }, (d3.geo.winkel3 = function () {
                    return ba(aa)
                }).raw = aa
            }();
